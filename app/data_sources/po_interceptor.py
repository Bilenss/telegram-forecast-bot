# app/data_sources/po_interceptor.py
"""
–ü–µ—Ä–µ—Ö–≤–∞—Ç —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö —Å PocketOption —á–µ—Ä–µ–∑ –±—Ä–∞—É–∑–µ—Ä
"""
import asyncio
import json
import pandas as pd
from playwright.async_api import async_playwright
from loguru import logger
import re

class PocketOptionInterceptor:
    """
    –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≥—Ä–∞—Ñ–∏–∫–æ–≤ PocketOption
    """
    
    def __init__(self):
        self.collected_data = []
        self.chart_data = None
    
    async def intercept_chart_data(self, symbol: str, timeframe: str, otc: bool = False) -> pd.DataFrame:
        """
        –ó–∞–ø—É—Å–∫–∞–µ—Ç –±—Ä–∞—É–∑–µ—Ä –∏ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –≥—Ä–∞—Ñ–∏–∫–∞
        """
        logger.info(f"Starting data interception for {symbol} {timeframe}")
        
        async with async_playwright() as p:
            browser = await p.chromium.launch(
                headless=False,  # –ú–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å True –ø–æ—Å–ª–µ –æ—Ç–ª–∞–¥–∫–∏
                args=['--disable-blink-features=AutomationControlled']
            )
            
            context = await browser.new_context(
                viewport={'width': 1920, 'height': 1080},
                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0'
            )
            
            page = await context.new_page()
            
            # –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º —Å–µ—Ç–µ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã
            async def handle_route(route):
                request = route.request
                url = request.url
                
                # –õ–æ–≥–∏—Ä—É–µ–º –≤—Å–µ –∑–∞–ø—Ä–æ—Å—ã –∫ API
                if any(x in url for x in ['api', 'socket', 'chart', 'candle', 'history']):
                    logger.debug(f"API Request: {url}")
                
                await route.continue_()
            
            # –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç—ã
            async def handle_response(response):
                url = response.url
                
                # –ò—â–µ–º –¥–∞–Ω–Ω—ã–µ –≥—Ä–∞—Ñ–∏–∫–æ–≤ –≤ –æ—Ç–≤–µ—Ç–∞—Ö
                patterns = [
                    'candles', 'history', 'chart', 'ohlc', 
                    'quotes', 'api/v', 'socket.io'
                ]
                
                if any(pattern in url.lower() for pattern in patterns):
                    try:
                        content_type = response.headers.get('content-type', '')
                        if 'json' in content_type or 'application/json' in content_type:
                            data = await response.json()
                            
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ—Ö–æ–∂–µ –ª–∏ –Ω–∞ OHLC –¥–∞–Ω–Ω—ã–µ
                            if self._is_chart_data(data):
                                logger.info(f"üìä Found chart data in: {url}")
                                self.collected_data.append(data)
                                
                    except Exception as e:
                        pass
            
            # –ü–µ—Ä–µ—Ö–≤–∞—Ç WebSocket —Å–æ–æ–±—â–µ–Ω–∏–π
            def handle_websocket(ws):
                logger.info(f"WebSocket connected: {ws.url}")
                
                def on_frame(payload):
                    # –ü–∞—Ä—Å–∏–º socket.io —Å–æ–æ–±—â–µ–Ω–∏—è
                    if isinstance(payload, str):
                        # Socket.io —Ñ–æ—Ä–º–∞—Ç: "42[event,data]"
                        if payload.startswith('42'):
                            try:
                                json_str = payload[2:]  # –£–±–∏—Ä–∞–µ–º "42"
                                data = json.loads(json_str)
                                
                                if self._is_chart_data(data):
                                    logger.info("üìä Found chart data in WebSocket")
                                    self.collected_data.append(data)
                                    
                            except:
                                pass
                
                ws.on("framereceived", lambda e: on_frame(e.payload if hasattr(e, 'payload') else str(e)))
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
            await page.route("**/*", handle_route)
            page.on("response", handle_response)
            page.on("websocket", handle_websocket)
            
            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ PocketOption
            url = "https://pocketoption.com/en/cabinet/demo-quick-high-low/"
            if symbol:
                # –î–æ–±–∞–≤–ª—è–µ–º —Å–∏–º–≤–æ–ª –≤ URL
                clean_symbol = symbol.replace('/', '').upper()
                if otc:
                    clean_symbol += "_otc"
                url += f"#{clean_symbol}"
            
            logger.info(f"Navigating to: {url}")
            await page.goto(url, wait_until='networkidle')
            
            # –ñ–¥–µ–º –∑–∞–≥—Ä—É–∑–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∞
            await page.wait_for_selector('canvas, iframe, [class*="chart"]', timeout=10000)
            await asyncio.sleep(3)
            
            # –ü—Ä–æ–±—É–µ–º –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ –∫–æ–Ω—Å–æ–ª—å –±—Ä–∞—É–∑–µ—Ä–∞
            try:
                chart_data = await page.evaluate("""
                    () => {
                        // –ò—â–µ–º –æ–±—ä–µ–∫—Ç –≥—Ä–∞—Ñ–∏–∫–∞ –≤ window
                        if (window.chart) return window.chart.data;
                        if (window.Chart) return window.Chart.data;
                        if (window.tvChart) return window.tvChart.data;
                        if (window.tradingView) return window.tradingView.activeChart?.data;
                        
                        // –ò—â–µ–º –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
                        for (let key in window) {
                            if (key.includes('chart') || key.includes('Chart')) {
                                if (window[key]?.data) return window[key].data;
                            }
                        }
                        
                        return null;
                    }
                """)
                
                if chart_data:
                    logger.info("‚úÖ Got chart data from JavaScript")
                    self.chart_data = chart_data
                    
            except Exception as e:
                logger.error(f"JS evaluation error: {e}")
            
            # –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö
            await asyncio.sleep(5)
            
            # –ü—Ä–æ–±—É–µ–º –∫–ª–∏–∫–Ω—É—Ç—å –Ω–∞ —Ä–∞–∑–Ω—ã–µ —Ç–∞–π–º—Ñ—Ä–µ–π–º—ã –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
            timeframe_map = {
                '1m': '1',
                '5m': '5', 
                '15m': '15',
                '30m': '30',
                '1h': '60'
            }
            
            if timeframe in timeframe_map:
                try:
                    tf_selector = f'[data-time="{timeframe_map[timeframe]}"], button:has-text("{timeframe}")'
                    await page.click(tf_selector, timeout=3000)
                    await asyncio.sleep(2)
                except:
                    pass
            
            await browser.close()
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–±—Ä–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            if self.collected_data:
                return self._process_collected_data()
            elif self.chart_data:
                return self._process_chart_data(self.chart_data)
            else:
                logger.warning("No data intercepted")
                return pd.DataFrame()
    
    def _is_chart_data(self, data):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –ø–æ—Ö–æ–∂–∏ –ª–∏ –¥–∞–Ω–Ω—ã–µ –Ω–∞ OHLC"""
        if isinstance(data, list) and len(data) > 0:
            first = data[0]
            if isinstance(first, dict):
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ OHLC –ø–æ–ª–µ–π
                ohlc_fields = {'open', 'high', 'low', 'close', 'o', 'h', 'l', 'c'}
                time_fields = {'time', 'timestamp', 't', 'date'}
                
                has_ohlc = any(f in str(first).lower() for f in ohlc_fields)
                has_time = any(f in str(first).lower() for f in time_fields)
                
                return has_ohlc or (has_time and len(first) >= 4)
        
        elif isinstance(data, dict):
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–ª–æ–∂–µ–Ω–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
            for key, value in data.items():
                if 'candle' in key.lower() or 'data' in key.lower():
                    return self._is_chart_data(value)
        
        return False
    
    def _process_collected_data(self):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–µ—Ä–µ—Ö–≤–∞—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ"""
        all_candles = []
        
        for data_chunk in self.collected_data:
            if isinstance(data_chunk, list):
                all_candles.extend(data_chunk)
            elif isinstance(data_chunk, dict):
                # –ò—â–µ–º –º–∞—Å—Å–∏–≤ —Å–≤–µ—á–µ–π –≤ –æ–±—ä–µ–∫—Ç–µ
                for key, value in data_chunk.items():
                    if isinstance(value, list) and len(value) > 0:
                        all_candles.extend(value)
        
        if not all_candles:
            return pd.DataFrame()
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ DataFrame
        df = pd.DataFrame(all_candles)
        
        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä—É–µ–º –Ω–∞–∑–≤–∞–Ω–∏—è –∫–æ–ª–æ–Ω–æ–∫
        rename_map = {
            'o': 'Open', 'h': 'High', 'l': 'Low', 'c': 'Close',
            'open': 'Open', 'high': 'High', 'low': 'Low', 'close': 'Close',
            't': 'time', 'timestamp': 'time'
        }
        
        df.rename(columns=rename_map, inplace=True)
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω–¥–µ–∫—Å
        if 'time' in df.columns:
            df['time'] = pd.to_datetime(df['time'], unit='s')
            df.set_index('time', inplace=True)
        
        # –í—ã–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ OHLC –∫–æ–ª–æ–Ω–∫–∏
        ohlc_cols = ['Open', 'High', 'Low', 'Close']
        available_cols = [col for col in ohlc_cols if col in df.columns]
        
        if len(available_cols) == 4:
            return df[available_cols]
        
        return pd.DataFrame()
    
    def _process_chart_data(self, chart_data):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ JavaScript"""
        try:
            if isinstance(chart_data, str):
                chart_data = json.loads(chart_data)
            
            return self._process_collected_data([chart_data])
        except:
            return pd.DataFrame()

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
async def get_real_po_data(symbol: str, timeframe: str, otc: bool = False):
    """–ü–æ–ª—É—á–∞–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å PocketOption"""
    interceptor = PocketOptionInterceptor()
    
    try:
        df = await interceptor.intercept_chart_data(symbol, timeframe, otc)
        
        if len(df) > 0:
            logger.info(f"‚úÖ Got {len(df)} real candles from PocketOption")
            return df
        else:
            logger.warning("No data intercepted, using fallback")
            return None
            
    except Exception as e:
        logger.error(f"Interception failed: {e}")
        return None
